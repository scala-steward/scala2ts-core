<%-- Typescript Type Template --%>
<%@ val config: com.github.scala2ts.configuration.Configuration %>
<%@ val tpe: com.github.scala2ts.model.Typescript.TypeRef %>
#match(tpe)
#case(arr: com.github.scala2ts.model.Typescript.ArrayRef)
Array<${unescape(capture(render("type.ssp", Map("tpe" -> arr.innerType, "config" -> config))).trim)}>
#case(option: com.github.scala2ts.model.Typescript.OptionRef)
${unescape(capture(render("type.ssp", Map("tpe" -> option.typeRef, "config" -> config))).trim)} | null
#case(union: com.github.scala2ts.model.Typescript.UnionType)
${union.possibilities.map(tpe => unescape(capture(render("type.ssp", Map("tpe" -> tpe, "config" -> config))).trim)).mkString(" | ")}
#case(map: com.github.scala2ts.model.Typescript.MapType)
{ [key: ${unescape(capture(render("type.ssp", Map("tpe" -> map.keyType, "config" -> config))).trim)}]: ${unescape(capture(render("type.ssp", Map("tpe" -> map.keyType, "config" -> config))).trim)} }
#case(tpe: com.github.scala2ts.model.Typescript.CustomTypeRef)
<%-- The below looks pretty bad, but we're playing in scalate's rendering semantics here --%>
<%-- Tried using <%%> and binding the rendering output to a val but it didn't like that --%>
${tpe.name}#if(tpe.typeArgs.nonEmpty)<#for((arg, i) <- tpe.typeArgs.zipWithIndex)${unescape(capture(render("type.ssp", Map("tpe" -> arg, "config" -> config))).trim)}#if(i < tpe.typeArgs.size - 1), #end#end>#end
#otherwise
${tpe.toString.trim}
#end