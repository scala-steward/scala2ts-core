<%-- Typescript Interface/Class Field Template --%>
<%@ val config: com.github.scala2ts.configuration.Configuration %>
<%@ val member: com.github.scala2ts.model.Typescript.Member %>
#match(member.typeRef)
  #case(option: com.github.scala2ts.model.Typescript.OptionRef)
    ${member.name}?: ${unescape(capture(render("type.ssp", Map("tpe" -> option.typeRef, "config" -> config))).trim)};
  #case(arr: com.github.scala2ts.model.Typescript.ArrayRef)
    ${member.name}: Array<${unescape(capture(render("type.ssp", Map("tpe" -> arr.innerType, "config" -> config))).trim)}>;
  #case(custom: com.github.scala2ts.model.Typescript.CustomTypeRef)
    <%-- The below looks pretty bad, but we're playing in scalate's rendering semantics here --%>
    <%-- Tried using <%%> and binding the rendering output to a val but it didn't like that --%>
    ${member.name}: ${custom.name}#if(custom.typeArgs.nonEmpty)<#for((arg, i) <- custom.typeArgs.zipWithIndex)${unescape(capture(render("type.ssp", Map("tpe" -> arg, "config" -> config))).trim)}#if(i < custom.typeArgs.size - 1), #end#end>;
    #end
  #otherwise
    ${member.name}: ${member.typeRef};
#end